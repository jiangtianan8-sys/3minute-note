volatile关键字虽然拥有多个线程之间的可见性，但是却不具备同步性（也就是原子性），可以算上是一个轻量级的synchronized，性能却要比synchronized强很多，不会造成阻塞（在很多的开源框架里，比如netty的底层代码就大量使用volatile，可见netty性能一定是非常不错的）这里需要注意，一般volatile用于只针对于多个线程可见的变量操作，并不能代替synchronized的同步功能。

VolatileNoAtomic

/**

* volatile关键字不具备synchronized关键字的原子性（同步）

* @author alienware

*

*/

public class VolatileNoAtomic extends Thread{

private static volatile int count;

//private static AtomicInteger count = new AtomicInteger(0);

private static void addCount(){

for (int i = 0; i < 1000; i++) {

count++ ;

//count.incrementAndGet();

}

System.out.println(count);

}

public void run(){

addCount();

}

public static void main(String[] args) {

VolatileNoAtomic[] arr = new VolatileNoAtomic[100];

for (int i = 0; i < 10; i++) {

arr[i] = new VolatileNoAtomic();

}

for (int i = 0; i < 10; i++) {

arr[i].start();

}

}

}

示例总结：

volatile关键字只具有可见性，没有原子性。要实现原子性建议使用atomic类的系列对象，支持原子性操作。（注意atomic类只保证本身方法原子性，并不保证多次操作的原子性）

AtomicUse

public class AtomicUse {

private static AtomicInteger count = new AtomicInteger(0);

//多个addAndGet在一个方法内是非原子性的，需要加synchronized进行修饰，保证4个addAndGet整体原子性

/**synchronized*/

public synchronized int multiAdd(){

try {

Thread.sleep(100);

} catch (InterruptedException e) {

e.printStackTrace();

}

count.addAndGet(1);

count.addAndGet(2);

count.addAndGet(3);

count.addAndGet(4); //+10

return count.get();

}

public static void main(String[] args) {

final AtomicUse au = new AtomicUse();

List ts = new ArrayList();

for (int i = 0; i < 100; i++) {

ts.add(new Thread(new Runnable() {

@Override

public void run() {

System.out.println(au.multiAdd());

}

}));

}

for(Thread t : ts){

t.start();

}

}

}