在java多线程中，我们知道可以使用synchronized关键字来实现线程间的同步互斥工作，那么其实还有一个更优秀的机制去完成这个“同步互斥”工作，他就是Lock对象，我们主要学习两种锁，重入锁和读写锁。他们具有比synchronized更为强大的功能，并且有嗅探锁定，多路分支等功能。

ReentrantLock（重入锁）

重入锁，在需要进行同步的代码加上锁定，但不要忘记最后一定要释放锁定，不然会造成锁永远无法释放，其他线程永远进不来的结果。

UseReentrantLock

锁与等待／通知

还记得我们在使用synchronized的时候，如果需要多线程间进行协调工作则需要Object的wait（）

和notify（），nofityAll（）方法进行配合工作。

一般而言，都会将Condition变量作为成员变量。当调用await方法后，当前线程会释放锁并进入Condition变量的等待队列，而其他线程调用signal方法后，通知正在Condition变量等待队列的线程从await方法返回，并且在返回前已经获得了锁。

那么同样，我们在使用Lock的时候，可以使用一个新的等待／通知的类，它就是Condition。这个Condition一定是针对具体某一把锁的，也就是在只有锁的基础上才会产生Condition。

public class UseCondition {

private Lock lock = new ReentrantLock();

private Condition condition = lock.newCondition();

public void method1(){

try {

lock.lock();

System.out.println("当前线程：" + Thread.currentThread().getName() + "进入等待状态..");

Thread.sleep(3000);

System.out.println("当前线程：" + Thread.currentThread().getName() + "释放锁..");

condition.await(); // Object wait

System.out.println("当前线程：" + Thread.currentThread().getName() +"继续执行...");

} catch (Exception e) {

e.printStackTrace();

} finally {

lock.unlock();

}

}

public void method2(){

try {

lock.lock();

System.out.println("当前线程：" + Thread.currentThread().getName() + "进入..");

Thread.sleep(3000);

System.out.println("当前线程：" + Thread.currentThread().getName() + "发出唤醒..");

condition.signal(); //Object notify

} catch (Exception e) {

e.printStackTrace();

} finally {

lock.unlock();

}

}

public static void main(String[] args) {

final UseCondition uc = new UseCondition();

Thread t1 = new Thread(new Runnable() {

@Override

public void run() {

uc.method1();

}

}, "t1");

Thread t2 = new Thread(new Runnable() {

@Override

public void run() {

uc.method2();

}

}, "t2");

t1.start();

t2.start();

}

}

多Condition

我们可以通过一个Lock对象产生多个Condition进行多线程间的交互，非常的灵活。可以使得部分需要唤醒的线程唤醒，其他线程则继续等待通知。

public class UseManyCondition {

private ReentrantLock lock = new ReentrantLock();

private Condition c1 = lock.newCondition();

private Condition c2 = lock.newCondition();

public void m1(){

try {

lock.lock();

System.out.println("当前线程：" +Thread.currentThread().getName() + "进入方法m1等待..");

c1.await();

System.out.println("当前线程：" +Thread.currentThread().getName() + "方法m1继续..");

} catch (Exception e) {

e.printStackTrace();

} finally {

lock.unlock();

}

}

public void m2(){

try {

lock.lock();

System.out.println("当前线程：" +Thread.currentThread().getName() + "进入方法m2等待..");

c1.await();

System.out.println("当前线程：" +Thread.currentThread().getName() + "方法m2继续..");

} catch (Exception e) {

e.printStackTrace();

} finally {

lock.unlock();

}

}

public void m3(){

try {

lock.lock();

System.out.println("当前线程：" +Thread.currentThread().getName() + "进入方法m3等待..");

c2.await();

System.out.println("当前线程：" +Thread.currentThread().getName() + "方法m3继续..");

} catch (Exception e) {

e.printStackTrace();

} finally {

lock.unlock();

}

}

public void m4(){

try {

lock.lock();

System.out.println("当前线程：" +Thread.currentThread().getName() + "唤醒..");

c1.signalAll();

} catch (Exception e) {

e.printStackTrace();

} finally {

lock.unlock();

}

}

public void m5(){

try {

lock.lock();

System.out.println("当前线程：" +Thread.currentThread().getName() + "唤醒..");

c2.signal();

} catch (Exception e) {

e.printStackTrace();

} finally {

lock.unlock();

}

}

public static void main(String[] args) {

final UseManyCondition umc = new UseManyCondition();

Thread t1 = new Thread(new Runnable() {

@Override

public void run() {

umc.m1();

}

},"t1");

Thread t2 = new Thread(new Runnable() {

@Override

public void run() {

umc.m2();

}

},"t2");

Thread t3 = new Thread(new Runnable() {

@Override

public void run() {

umc.m3();

}

},"t3");

Thread t4 = new Thread(new Runnable() {

@Override

public void run() {

umc.m4();

}

},"t4");

Thread t5 = new Thread(new Runnable() {

@Override

public void run() {

umc.m5();

}

},"t5");

t1.start(); // c1

t2.start(); // c1

t3.start(); // c2

try {

Thread.sleep(2000);

} catch (InterruptedException e) {

e.printStackTrace();

}

t4.start(); // c1

try {

Thread.sleep(2000);

} catch (InterruptedException e) {

e.printStackTrace();

}

t5.start(); // c2

}

}