synchronized锁重入：

      关键字synchronized拥有锁重入的功能，也就是在使用synchronized时，当一个线程得到了一个对象的锁后，再次请求此对象时是可以再次得到该对象的锁。

1.可重入锁

　　如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。

　　看下面这段代码就明白了：

|                                                                           |                                                                                                                                                                              |
| ------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9 | class MyClass {<br><br>    public synchronized void method1() {<br><br>        method2();<br><br>    }<br><br>    public synchronized void method2() {<br><br>    }<br><br>} |

 　　上述代码中的两个方法method1和method2都用synchronized修饰了，假如某一时刻，线程A执行到了method1，此时线程A获取了这个对象的锁，而由于method2也是synchronized方法，假如synchronized不具备可重入性，此时线程A需要重新申请锁。但是这就会造成一个问题，因为线程A已经持有了该对象的锁，而又在申请获取该对象的锁，这样就会线程A一直等待永远不会获取到的锁。

　　而由于synchronized和Lock都具备可重入性，所以不会发生上述现象。

```java
/**

* synchronized的重入

* @author alienware

*

*/

public class SyncDubbo2 {

static class Main {

public int i = 10;

public synchronized void operationSup(){

try {

i--;

System.out.println("Main print i = " + i);

Thread.sleep(100);

} catch (InterruptedException e) {

e.printStackTrace();

}

}

}

static class Sub extends Main {

public synchronized void operationSub(){

try {

while(i > 0) {

i--;

System.out.println("Sub print i = " + i);

Thread.sleep(100);

this.operationSup();

}

} catch (InterruptedException e) {

e.printStackTrace();

}

}

}

public static void main(String[] args) {

Thread t1 = new Thread(new Runnable() {

@Override

public void run() {

Sub sub = new Sub();

sub.operationSub();

}

});

t1.start();

}

}
```