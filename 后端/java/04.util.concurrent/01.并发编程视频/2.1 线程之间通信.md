线程通信概念：线程是操作系统中独立的个体，但这些个体如果不经过特殊的处理就不能成为一个整体，线程间的通信就成为整体的必用方式之一。当线程存在通信指挥，系统间的交互性会更强大，在提高CPU利用率的同时还会使开发人员对线程任务在处理的过程中进行有效的把控与监督。

使用wait／notify方法实现线程间的通信。（注意这两个方法都是object的类的方法，换句话说java为所有的对象都提供了这2个方法）

1 wait／notify必须配合synchronized关键字使用

2 wait方法释放锁，notify方法不释放锁。

- wait() 、nofify() 、nofityAll() 调用的前提都是获得了对象的锁(也可称为对象监视器)。
- 调用 wait() 方法后线程会释放锁，进入 WAITING 状态，该线程也会被移动到等待队列中。
- 调用 notify() 方法会将等待队列中的线程移动到同步队列中，线程状态也会更新为 BLOCKED
- 从 wait() 方法返回的前提是调用 notify() 方法的线程释放锁，wait() 方法的线程获得锁。

等待通知有着一个经典范式：

线程 A 作为消费者：

1. 获取对象的锁。
2. 进入 while(判断条件)，并调用 wait() 方法。
3. 当条件满足跳出循环执行具体处理逻辑。

线程 B 作为生产者:

1. 获取对象锁。
2. 更改与线程 A 共用的判断条件。
3. 调用 notify() 方法。

伪代码如下:

//Thread A synchronized(Object){ while(条件){ Object.wait(); } //do something } //Thread B synchronized(Object){ 条件=false;//改变条件 Object.notify(); }

join() 方法

private static void join() throws InterruptedException { Thread t1 = new Thread(new Runnable() { @Override public void run() { LOGGER.info("running"); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } } }) ; Thread t2 = new Thread(new Runnable() { @Override public void run() { LOGGER.info("running2"); try { Thread.sleep(4000); } catch (InterruptedException e) { e.printStackTrace(); } } }) ; t1.start(); t2.start(); //等待线程1终止 t1.join(); //等待线程2终止 t2.join(); LOGGER.info("main over"); }

输出结果:

2018-03-16 20:21:30.967 [Thread-1] INFO c.c.actual.ThreadCommunication - running2 2018-03-16 20:21:30.967 [Thread-0] INFO c.c.actual.ThreadCommunication - running 2018-03-16 20:21:34.972 [main] INFO c.c.actual.ThreadCommunication - main over

在 t1.join() 时会一直阻塞到 t1 执行完毕，所以最终主线程会等待 t1 和 t2 线程执行完毕。

其实从源码可以看出，join() 也是利用的等待通知机制：

核心逻辑:

while (isAlive()) { wait(0); }

在 join 线程完成后会调用 notifyAll() 方法，是在 JVM 实现中调用，所以这里看不出来。

来源： [https://my.oschina.net/crossoverjie/blog/1647025](https://my.oschina.net/crossoverjie/blog/1647025)

示例

ListAdd1

public class ListAdd1 {

private volatile static List list = new ArrayList();

public void add(){

list.add("bjsxt");

}

public int size(){

return list.size();

}

public static void main(String[] args) {

final ListAdd1 list1 = new ListAdd1();

Thread t1 = new Thread(new Runnable() {

@Override

public void run() {

try {

for(int i = 0; i <10; i++){

list1.add();

System.out.println("当前线程：" + Thread.currentThread().getName() + "添加了一个元素..");

Thread.sleep(500);

}

} catch (InterruptedException e) {

e.printStackTrace();

}

}

}, "t1");

Thread t2 = new Thread(new Runnable() {

@Override

public void run() {

while(true){

if(list1.size() == 5){

System.out.println("当前线程收到通知：" + Thread.currentThread().getName() + " list size = 5 线程停止..");

throw new RuntimeException();

}

}

}

}, "t2");

t1.start();

t2.start();

}

}

ListAdd2

/**

* wait notfiy 方法，wait释放锁，notfiy不释放锁

* @author alienware

*

*/

public class ListAdd2 {

private volatile static List list = new ArrayList();

public void add(){

list.add("bjsxt");

}

public int size(){

return list.size();

}

public static void main(String[] args) {

final ListAdd2 list2 = new ListAdd2();

// 1 实例化出来一个 lock

// 当使用wait 和 notify 的时候 ， 一定要配合着synchronized关键字去使用

final Object lock = new Object();

//final CountDownLatch countDownLatch = new CountDownLatch(1);

Thread t1 = new Thread(new Runnable() {

@Override

public void run() {

try {

//synchronized (lock) {

for(int i = 0; i <10; i++){

list2.add();

System.out.println("当前线程：" + Thread.currentThread().getName() + "添加了一个元素..");

Thread.sleep(500);

if(list2.size() == 5){

System.out.println("已经发出通知..");

//countDownLatch.countDown();

lock.notify();

}

}

//}

} catch (InterruptedException e) {

e.printStackTrace();

}

}

}, "t1");

Thread t2 = new Thread(new Runnable() {

@Override

public void run() {

//synchronized (lock) {

if(list2.size() != 5){

try {

System.out.println("t2进入...");

lock.wait();

//countDownLatch.await();

} catch (InterruptedException e) {

e.printStackTrace();

}

//}

System.out.println("当前线程：" + Thread.currentThread().getName() + "收到通知线程停止..");

throw new RuntimeException();

}

}

}, "t2");

t2.start();

t1.start();

}

}