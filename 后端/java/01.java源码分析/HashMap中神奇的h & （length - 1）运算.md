众所周知，HashMap 是基于 Hash 表的 Map 接口实现，HashMap 实际上是一个“链表散列”的数据结构，即数组和链表的结合体。HashMap 中主要是通过 key 的 hashCode 来计算 hash 值的，只要 hashCode 相同，计算出来的 hash 值就一样。但是知道了 Hash 值之后，又是怎么确定出 key 在数组中的索引呢？

根据源码得知如下方法

static int indexFor(int h, int length) { //根据 hash 值和数组长度算出索引值

         return h & (length-1);  

这样做有什么好处呢 ？

1、保证不会发生数组越界

首先我们要知道的是，在 HashMap，数组的长度按规定一定是 2 的幂。因此，数组的长度的二进制形式是：10000…000, 1 后面有偶数个 0。 那么，length - 1 的二进制形式就是 01111.111, 0 后面有偶数个 1。最高位是 0, 和 hash 值相“与”，结果值一定不会比数组的长度值大，因此也就不会发生数组越界。

2、保证元素尽可能的均匀分布

由上边的分析可知，length 一定是一个偶数，length - 1 一定是一个奇数。假设现在数组的长度 length 为 16，减去 1 后 length - 1 就是 15，15 对应的二进制是：1111。现在假设有两个元素需要插入，一个哈希值是 8，二进制是 1000，一个哈希值是 9，二进制是 1001。和 1111“与”运算后，结果分别是 1000 和 1001，它们被分配在了数组的不同位置，这样，哈希的分布非常均匀。那么，如果数组长度是奇数呢？减去 1 后 length - 1 就是偶数了，偶数对应的二进制最低位一定是 0，例如 14 二进制 1110。对上面两个数子分别“与”运算，得到 1000 和 1000。结果都是一样的值。那么，哈希值 8 和 9 的元素都被存储在数组同一个 index 位置的链表中。在操作的时候，链表中的元素越多，效率越低，因为要不停的对链表循环比较。

来源： [https://my.oschina.net/ManderSY/blog/1604790](https://my.oschina.net/ManderSY/blog/1604790)
