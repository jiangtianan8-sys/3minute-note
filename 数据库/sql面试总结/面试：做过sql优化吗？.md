近来面试找工作经常会遇见这种问题： 做过数据库优化吗？大数据量基础过吗？系统反应慢怎么查询？

　　这咱也没背过啊，面试还老问，现在的网站主要的压力都来自于数据库，频繁的数据库访问经常会使系统瘫痪，这样就需要进行 sql 优化。明天去 58 面试，今天来梳理一下。

1. 写明查询具体某几列，减少 * 的使用，表名过长时,尽量使用表的别名

　　* 和列名一样

2，在业务密集的 SQL 当中尽量不采用 IN 操作符，用 EXISTS 方案代替。

　　in 和 exists 的区别: 如果子查询得出的结果集记录较少，主查询中的表较大且又有索引时应该用 in, 反之如果外层的主查询记录较少，子查询中的表大，又有索引时使用 exists。其实我们区分 in 和 exists 主要是造成了驱动顺序的改变 (这是性能变化的关键)，如果是 exists，那么以外层表为驱动表，先被访问，如果是 IN，那么先执行子查询，所以我们会以驱动表的快速返回为目标，那么就会考虑到索引及结果集的关系了 ，另外 IN 时不对 NULL 进行处理。

　　in 是把外表和内表作 hash 连接，而 exists 是对外表作 loop 循环，每次 loop 循环再对内表进行查询。一直以来认为 exists 比 in 效率高的说法是不准确的。

3、模糊查询 like，尽量少用%

　　关键词%yue%，由于 yue 前面用到了“%”，因此该查询必然走全表扫描，除非必要，否则不要在关键词前加%，

4， 二者都能使用尽量使用 where （与 having 比较）

　　where 先过滤（数据就少了）再分组  

5，尽量使用多表连接（join）查询（避免子查询）

　　子查询效率特别低，而一般的子查询都可以由关连查询来实现相同的功能，关联查询的效率要提高很多，所以建议在数据查询时避免使用子查询（尤其是在记录很多时），而最好用关联查询来实现。

6，建立索引

　　较频繁地作为查询条件的字段，唯一性不太差的字段适合建立索引，更新不太频繁地字段适合创建索引，不会出现在 where 条件中的字段不该建立索引

7，多使用内部函数提高 SQL 效率

　　例如多用 concat 连接,代替 '||' 的符号连接

8，应尽量避免在 where 子句中使用 != 或 <> ，in 或 not in

　　最好不要给数据库留 NULL，尽可能的使用 NOT NULL 填充数据库 （不然会进行全表扫描，影响效率） 

9，尽可能的使用 varchar/nvarchar 代替 char/nchar （节省字段存储空间）
