InnoDB is a [multi-versioned storage engine](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_mvcc): it keeps information about old versions of changed rows, to support transactional features such as concurrency and [rollback](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_rollback). This information is stored in the tablespace in a data structure called a [rollback segment](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_rollback_segment) (after an analogous data structure in Oracle). InnoDB uses the information in the rollback segment to perform the undo operations needed in a transaction rollback. It also uses the information to build earlier versions of a row for a [consistent read](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_consistent_read).

InnoDB 是一个多版本的存储引擎，所以它必须在表空间中保存 row 的旧的版本。这些 row 的旧的版本被保存在称为 rollback segment 的数据结构中。

Internally, InnoDB adds three fields to each row stored in the database. A 6-byte DB_TRX_ID field indicates the transaction identifier for the last transaction that inserted or updated the row. Also, a deletion is treated internally as an update where a special bit in the row is set to mark it as deleted. Each row also contains a 7-byte DB_ROLL_PTR field called the roll pointer. The roll pointer points to an undo log record written to the rollback segment. If the row was updated, the undo log record contains the information necessary to rebuild the content of the row before it was updated. A 6-byte DB_ROW_ID field contains a row ID that increases monotonically as new rows are inserted. If InnoDB generates a clustered index automatically, the index contains row ID values. Otherwise, the DB_ROW_ID column does not appear in any index.

为了支持 MVCC, InnoDB 内部实现的时候为每 row 增加了三个字段：

1. 6 byte DB_TRX_ID: 代表最后插入或者更新该行的 Transaction Identifier. 删除操作也被当做更新操作，只是在该行上加了一个特殊比特作为标志。
2. 7 byte DB_ROLL_PTR：这个指向 undo log 的链表，如果该 row 被更新了，该 row 中原先内容将会被移到 undo log 中作为最前面的 undo log 的节点
3. 6 byte DB_ROW_ID：当该 row 所在表新增加一行时， 新增 row 中的 DB_ROW_ID 会增加 。。。

InnoDB uses the information in the rollback segment to perform the undo operations needed in a transaction rollback. It also uses the information to build earlier versions of a row for a consistent read.

undo log 有两个作用：undo log 链表的第一个节点可以用来 rollback 的时候恢复。undo log 链表中其他节点用来在 REPEATED_READ 的情况下给哪些活的 Transaction 提供一致读的效果的。

Undo logs in the rollback segment are divided into insert and update undo logs. Insert undo logs are needed only in transaction rollback and can be discarded as soon as the transaction commits. Update undo logs are used also in consistent reads, but they can be discarded only after there is no transaction present for which InnoDB has assigned a snapshot that in a consistent read could need the information in the update undo log to build an earlier version of a database row.

Undo log 分为 insert 和 update 两种。insert undo log 当新 insert row 的时候产生的，这些 undo log 只有在 Transaction rollback 的时候用来删除前面 insert 的行，只要这个 Transaction 一 commit 或者 discard,这个 insert undo log 就被丢弃掉了。 我们前面提的都是 update undo log 作用，就是前面说的“undo log”的两个作用，你想想，如果 undo log 链表中不是最前面的节点对应的 Transaction 已经不在了，这个节点还有存在的价值吗？因为没有 tranaction 去读它了。

Commit your transactions regularly, including those transactions that issue only consistent reads. Otherwise, InnoDB cannot discard data from the update undo logs, and the rollback segment may grow too big, filling up your tablespace.

The physical size of an undo log record in the rollback segment is typically smaller than the corresponding inserted or updated row. You can use this information to calculate the space needed for your rollback segment.

In the InnoDB multi-versioning scheme, a row is not physically removed from the database immediately when you delete it with an SQL statement. InnoDB only physically removes the corresponding row and its index records when it discards the update undo log record written for the deletion. This removal operation is called a [purge](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_purge), and it is quite fast, usually taking the same order of time as the SQL statement that did the deletion.

If you insert and delete rows in smallish batches at about the same rate in the table, the purge thread can start to lag behind and the table can grow bigger and bigger because of all the “dead” rows, making everything disk-bound and very slow. In such a case, throttle new row operations, and allocate more resources to the purge thread by tuning the [innodb_max_purge_lag](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_max_purge_lag) system variable. See [Section 14.14, “InnoDB Startup Options and System Variables”](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html) for more information.

Multi-Versioning and Secondary Indexes

InnoDB multiversion concurrency control (MVCC) treats secondary indexes differently than clustered indexes. Records in a clustered index are updated in-place, and their hidden system columns point undo log entries from which earlier versions of records can be reconstructed. Unlike clustered index records, secondary index records do not contain hidden system columns nor are they updated in-place.

When a secondary index column is updated, old secondary index records are delete-marked, new records are inserted, and delete-marked records are eventually purged. When a secondary index record is delete-marked or the secondary index page is updated by a newer transaction, InnoDB looks up the database record in the clustered index. In the clustered index, the record's DB_TRX_ID is checked, and the correct version of the record is retrieved from the undo log if the record was modified after the reading transaction was initiated.

If a secondary index record is marked for deletion or the secondary index page is updated by a newer transaction, the [covering index](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_covering_index) technique is not used. Instead of returning values from the index structure, InnoDB looks up the record in the clustered index.

However, if the [index condition pushdown (ICP)](https://dev.mysql.com/doc/refman/5.7/en/index-condition-pushdown-optimization.html) optimization is enabled, and parts of the WHERE condition can be evaluated using only fields from the index, the MySQL server still pushes this part of the WHERE condition down to the storage engine where it is evaluated using the index. If no matching records are found, the clustered index lookup is avoided. If matching records are found, even among delete-marked records, InnoDB looks up the record in the clustered index.
