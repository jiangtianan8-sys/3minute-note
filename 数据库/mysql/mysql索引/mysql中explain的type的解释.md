导语：

很多情况下，有很多人用各种 select 语句查询到了他们想要的数据后，往往便以为工作圆满结束了。

这些事情往往发生在一些学生亦或刚入职场但之前又没有很好数据库基础的小白身上，但所谓闻道有先后，只要我们小白好好学习，天天向上，还是很靠谱的。

当一个 sql 查询语句被写出来之后，其实你的工作只完成了一小半，接下来更重要的工作是评估你自己写的 sql 的质量与效率。mysql 为我们提供了很有用的辅助武器 explain，它向我们展示了 mysql 接收到一条 sql 语句的执行计划。根据 explain 返回的结果我们便可以知道我们的 sql 写的怎么样，是否会造成查询瓶颈，同时根据结果不断的修改调整查询语句，从而完成 sql 优化的过程。

![0](https://note.youdao.com/yws/res/1632/14FE6BB641614350BA5595D9859CDF1F)

虽然 explain 返回的结果项很多，这里我们只关注三种，分别是 type，key，rows。其中 key 表明的是这次查找中所用到的索引，rows 是指这次查找数据所扫描的行数（这里可以先这样理解，但实际上是内循环的次数）。而 type 则是本文要详细记录的连接类型，前两项重要而且简单，无需多说。

type -- 连接类型

type 意味着类型，这里的 type 官方全称是“join type”，意思是“连接类型”,这样很容易给人一种错觉觉得必须需要俩个表以上才有连接类型。事实上这里的连接类型并非字面那样的狭隘，它更确切的说是一种数据库引擎查找表的一种方式，在《高性能 mysql》一书中作者更是觉得称呼它为访问类型更贴切一些。

mysql5.7 中 type 的类型达到了 14 种之多，这里只记录和理解最重要且经常遇见的六种类型，它们分别是 all,index,range,ref,eq_ref，const。从左到右，它们的效率依次是增强的。撇开 sql 的具体应用环境以及其他因素，你应当尽量优化你的 sql 语句，使它的 type 尽量靠右，但实际运用中还是要综合考虑各个方面的。

接下来，为了演示和重现这几种连接类型，我新建了一个数据测试表，以方面更好的理解这五种类型。

1. | employee | CREATE TABLE `employee` (
2. `rec_id` int(11) NOT NULL AUTO_INCREMENT,
3. `no` varchar(10) NOT NULL,
4. `name` varchar(20) NOT NULL,
5. `position` varchar(20) NOT NULL,
6. `age` varchar(2) NOT NULL,
7. PRIMARY KEY (`rec_id`)
8. ) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 |

all

这便是所谓的“全表扫描”，如果是展示一个数据表中的全部数据项，倒是觉得也没什么，如果是在一个查找数据项的 sql 中出现了 all 类型，那通常意味着你的 sql 语句处于一种最原生的状态，有很大的优化空间。

为什么这么说呢？因为 all 是一种非常暴力和原始的查找方法，非常的耗时而且低效。用 all 去查找数据就好比这样的一个情形：S 学校有俩万人，我告诉你你给我找到小明，然后你怎么做呢！你当然是把全校俩万人挨个找一遍，即使你很幸运第一个人便找到了小明，但是你仍然不能停下，因为你无法确认是否有另外一个小明存在，直到你把俩万人找完为止。所以，基本所有情况，我们都要避免这样类型的查找，除非你不得不这样做。

以 employee 表为例，下面一种情形便是 all 类型的查找：

1. mysql> explain select * from employee where `no` = '20150001';
2. +----+-------------+----------+------+---------------+------+---------+------+------+-------------+
3. | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |
4. +----+-------------+----------+------+---------------+------+---------+------+------+-------------+
5. | 1 | SIMPLE | employee | ALL | NULL | NULL | NULL | NULL | 5 | Using where |
6. +----+-------------+----------+------+---------------+------+---------+------+------+-------------+

这是因为 no 列既不是主键也不是索引，因此只能采用全表扫描来查找目标 no。

index

这种连接类型只是另外一种形式的全表扫描，只不过它的扫描顺序是按照索引的顺序。这种扫描根据索引然后回表取数据，和 all 相比，他们都是取得了全表的数据，而且 index 要先读索引而且要回表随机取数据，因此 index 不可能会比 all 快（取同一个表数据），但为什么官方的手册将它的效率说的比 all 好，唯一可能的原因在于，按照索引扫描全表的数据是有序的。这样一来，结果不同，也就没法比效率的问题了。

如果一定要比效率，只需要获取这个表的数据并且排序便可以看出来谁比谁效率高了：

1. mysql> explain select * from employee order by `no` ;
2. +----+-------------+----------+------+---------------+------+---------+------+------+----------------+
3. | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |
4. +----+-------------+----------+------+---------------+------+---------+------+------+----------------+
5. | 1 | SIMPLE | employee | ALL | NULL | NULL | NULL | NULL | 5 | Using filesort |
6. +----+-------------+----------+------+---------------+------+---------+------+------+----------------+
7. mysql> explain select * from employee order by rec_id ;
8. +----+-------------+----------+-------+---------------+---------+---------+------+------+-------+
9. | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |
10. +----+-------------+----------+-------+---------------+---------+---------+------+------+-------+
11. | 1 | SIMPLE | employee | index | NULL | PRIMARY | 4 | NULL | 5 | NULL |
12. +----+-------------+----------+-------+---------------+---------+---------+------+------+-------+

上面可以看出，根据 no 列排序的连接类型是 all 型的，但是注意 extra 列是用到了排序（Using filesort），而根据 rec_id 列排序的连接类型是 index，而且得到的结果自然是有序的，不许额外的排序。可能正是因为这个缘故，index 的效率比 all 高，但注意这需要相同的条件才成立（既需要排序）。

如果连接类型为 type，而且 extra 列中的值为‘Using index’，那么称这种情况为 索引覆盖；

索引覆盖意味着什么呢？想象这样一种场景，如果说一本新华字典是一张表，当然前面的索引部分（假设按照部首的索引）是这张表的索引，那么索引覆盖就相当于根据部首索引获取第一个字到最后一个字（新华字典的所有字）。我们获得了字典中所有的字，然而我们并没有查一次表，因为我们想要的都早索引中，即索引覆盖。

1. mysql> explain select rec_id from employee ;
2. +----+-------------+----------+-------+---------------+---------+---------+------+------+-------------+
3. | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |
4. +----+-------------+----------+-------+---------------+---------+---------+------+------+-------------+
5. | 1 | SIMPLE | employee | index | NULL | PRIMARY | 4 | NULL | 5 | Using index |
6. +----+-------------+----------+-------+---------------+---------+---------+------+------+-------------+

上例获取的 rec_id 刚好为索引列，因此无需回表取数据。

range

range 指的是有范围的索引扫描，相对于 index 的全索引扫描，它有范围限制，因此要优于 index。关于 range 比较容易理解，需要记住的是出现了 range，则一定是基于索引的。同时除了显而易见的 between，and 以及 '>','<' 外，in 和 or 也是索引范围扫描。

ref

出现该连接类型的条件是： 查找条件列使用了索引而且不为主键和 unique。其实，意思就是虽然使用了索引，但该索引列的值并不唯一，有重复。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描。但它的好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描。下面为了演示这种情形，给 employee 表中的 name 列添加一个普通的 key（值允许重复）

alter table employee add key I_EMPLOYEE_NAME(`name`);

接下来，在 employee 表中根据 name 查找数据的时候，mysql 优化器便选择了 ref 的连接类型。

1. mysql> explain select * from employee where `name` = ' 张三 ';
2. +----+-------------+----------+------+----------------+----------------+---------+-------+------+-----------------------+
3. | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |
4. +----+-------------+----------+------+----------------+----------------+---------+-------+------+-----------------------+
5. | 1 | SIMPLE | employee | ref | I_EMPLOYEE_NAM | I_EMPLOYEE_NAM | 62 | const | 1 | Using index condition |
6. +----+-------------+----------+------+----------------+----------------+---------+-------+------+-----------------------+

ref_eq

ref_eq 与 ref 相比牛的地方是，它知道这种类型的查找结果集只有一个？什么情况下结果集只有一个呢！那便是使用了主键或者唯一性索引进行查找的情况，比如根据学号查找某一学校的一名同学，在没有查找前我们就知道结果一定只有一个，所以当我们首次查找到这个学号，便立即停止了查询。这种连接类型每次都进行着精确查询，无需过多的扫描，因此查找效率更高，当然列的唯一性是需要根据实际情况决定的。

在单个表中，曾尝试了很多方法想出现 ref_eq 的连接类型，然而很多时候出现的都是 const，因此不得不随手连接了一张表得到了想要的连接类型，该表的建表代买为。（博主比较懒，连接了两个没有关系的表，o(╯□╰)o）

1. CREATE TABLE `score` (
2. `rec_id` INT(11) NOT NULL AUTO_INCREMENT,
3. `stu_id` INT(11) NOT NULL,
4. `mark` INT(11) NOT NULL DEFAULT '0',
5. PRIMARY KEY (`rec_id`),
6. UNIQUE KEY `UK_SCORE_STU_ID` (`stu_id`)
7. ) ENGINE=INNODB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8

employee 表中有五条数据，score 表中有对应的五条数据，其中 employee 的 rec_id 和 score 的 stu_id 是一一对应的。

1. mysql> explain select ep.name,sc.mark from employee ep,score sc where ep.rec_id = sc.stu_id;
2. +----+-------------+-------+--------+-----------------+---------+---------+-----------------+------+-------+
3. | id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |
4. +----+-------------+-------+--------+-----------------+---------+---------+-----------------+------+-------+
5. | 1 | SIMPLE | sc | ALL | UK_SCORE_STU_ID | NULL | NULL | NULL | 5 | NULL |
6. | 1 | SIMPLE | ep | eq_ref | PRIMARY | PRIMARY | 4 | my_db.sc.stu_id | 1 | NULL |
7. +----+-------------+-------+--------+-----------------+---------+---------+-----------------+------+-------+

上面就可以看到 score 表是全表扫描的类型，rows=5 代表外层表循环了五次（因为有五条数据），但是 employee 表的 rows 怎么是 1，怎么可能？刚开始也是很疑惑，这与 mysql 的查询原理息息相关，rows 实际反映的是查询的内循环数，针对外层的每一条数据匹配，employee 的确一枪就可以命中，因此 rows 为 1。

const

通常情况下，如果将一个主键放置到 where 后面作为条件查询，mysql 优化器就能把这次查询优化转化为一个常量。至于如何转化以及何时转化，这个取决于优化器。

总结

explain 就像一面镜子，有事没事写完 sql 记得 explain 一下。同时，在写文章也发现，有很多东西和细节，想要明白清楚，也是没有那么简单的，需要对操作系统以及数据库的底层查询和运行原理要有一个清楚的理解。同时 type 的几种类型几乎都是基于索引之上的，因此需要对索引有个深入的了解，而且 explain 的结果可以指导我们什么时候加索引，什么时候不加索引，从而让我们更好的使用索引。

来源： [https://blog.csdn.net/dennis211/article/details/78170079](https://blog.csdn.net/dennis211/article/details/78170079)
