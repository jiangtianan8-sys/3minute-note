# 索引

MySQL 官方对索引的定义为：索引（Index）是帮助 MySQL 高效获取数据的数据结构。

我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是 [顺序查找](https://link.jianshu.com?t=http://en.wikipedia.org/wiki/Linear_search)（linear search），这种复杂度为 O(n) 的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如 [二分查找](https://link.jianshu.com?t=http://en.wikipedia.org/wiki/Binary_search_algorithm)（binary search）、[二叉树查找](https://link.jianshu.com?t=http://en.wikipedia.org/wiki/Binary_search_tree)（binary tree search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于 [二叉查找树](https://link.jianshu.com?t=http://en.wikipedia.org/wiki/Binary_search_tree) 上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。

看一个例子：

![](assets/干货：mysql索引的数据结构/file-20251124153815235.png)

图 1.png

图 1 展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快 Col2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在 O(log2n) 的复杂度内获取到相应数据。

虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种 [红黑树](https://link.jianshu.com?t=http://en.wikipedia.org/wiki/Red-black_tree)（red-black tree）实现的，原因会在下文介绍。

# B-Tree 和 B+Tree

目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构，在本文的下一节会结合存储器原理及计算机存取原理讨论为什么 B-Tree 和 B+Tree 在被如此广泛用于索引，这一节先单纯从数据结构角度描述它们。

## B-Tree

是一种多路搜索树（并不是二叉的）：

1.定义任意非叶子结点最多只有 M 个儿子；且 M>2；

2.根结点的儿子数为 [2, M]；

3.除根结点以外的非叶子结点的儿子数为 [M/2, M]；

4.每个结点存放至少 M/2-1（取上整）和至多 M-1 个关键字；（至少 2 个关键字）

5.非叶子结点的关键字个数=指向儿子的指针个数 -1；

6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且 K[i] < K[i+1]；

7.非叶子结点的指针：P[1], P[2], …, P[M]；其中 P[1] 指向关键字小于 K[1] 的

子树，P[M] 指向关键字大于 K[M-1] 的子树，其它 P[i] 指向关键字属于 (K[i-1], K[i]) 的子树；

8.所有叶子结点位于同一层；

9.每个 k 对应一个 data。

如：（M=3）相当于一个 2–3 树，2–3 树是一个这样的一棵树， 它的每个节点要么有 2 个孩子和 1 个数据元素，要么有 3 个孩子和 2 个数据元素，叶子节点没有孩子，并且有 1 个或 2 个数据元素。

![](assets/干货：mysql索引的数据结构/file-20251124153827652.png)

B- 树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；B-Tree 上查找算法的伪代码如下：

> `BTree_Search(node, key) { if(node == null) return null; foreach(node.key) { if(node.key[i] == key) return node.data[i]; if(node.key[i] > key) return BTree_Search(point[i]->node); } return BTree_Search(point[i+1]->node); } data = BTree_Search(root, my_key);`

- B- 树的特性：
    1.关键字集合分布在整颗树中；
    2.任何一个关键字出现且只出现在一个结点中；
    3.搜索有可能在非叶子结点结束；
    4.其搜索性能等价于在关键字全集内做一次二分查找；
    5.自动层次控制；
    
- B- 树的自控制:
    B 树中每一个内部节点会包含一定数量的键值。通常，键值的数量被选定在 d 和 2d 之间。在实际中，键值占用了节点中大部分的空间。因数 2 将保证节点可以被拆分或组合。如果一个内部节点有 2d 个键值，那么添加一个键值给此节点的过程，将会拆分 2d 键值为 2 个 d 键值的节点，并把此键值添加给父节点。每一个拆分的节点需要最小数目的键值。相似地，如果一个内部节点和他的邻居两者都有 d 个键值，那么将通过它与邻居的合并来删除一个键值。删除此键值将导致此节点拥有 d-1 个键值; 与邻居的合并则加上 d 个键值，再加上从邻居节点的父节点移来的一个键值。结果为完全填充的 2d 个键值。
    
- B- 树的构造过程：
    下面是往 B 树中依次插入
    6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4

    ![](assets/干货：mysql索引的数据结构/file-20251124153841434.png)

## B+Tree

B-Tree 有许多变种，其中最常见的是 B+Tree，例如 MySQL 就普遍使用 B+Tree 实现其索引结构。

- 与 B-Tree 相比，B+Tree 有以下不同点：
    1.非叶子结点的子树指针与关键字个数相同；
    2.非叶子结点的子树指针 P[i]，指向关键字值属于 [K[i], K[i+1]) 的子树（B- 树是开区间）；
    3.为所有叶子结点增加一个链指针；
    4.所有关键字都在叶子结点出现；
    5.内节点不存储 data，只存储 key
    如：（M=3）

    ![](assets/干货：mysql索引的数据结构/file-20251124153854985.png)

B+ 的搜索与 B- 树也基本相同，区别是 B+ 树只有达到叶子结点才命中（B- 树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；

- B+ 的特性：
    1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；
    2.不可能在非叶子结点命中；
    3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；
    4.更适合文件索引系统；
    
- B+ 树的构造过程：
    下面是往 B+ 树中依次插入
    6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4

    ![](assets/干货：mysql索引的数据结构/file-20251124153909486.png)

# 索引的物理存储

一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘 I/O 消耗，相对于内存存取，I/O 存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘 I/O 操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘 I/O 的存取次数。

## B-tree

![](assets/干货：mysql索引的数据结构/file-20251124153923117.png)

Paste_Image.png

假如每个盘块可以正好存放一个 B 树的结点（正好存放 2 个文件名）。那么一个 BTNODE 结点就代表一个盘块，而子树指针就是存放另外一个盘块的地址。

- 下面，咱们来模拟下查找文件 29 的过程：
    1.根据根结点指针找到文件目录的根磁盘块 1，将其中的信息导入内存。【磁盘 IO 操作 1 次】
    2.此时内存中有两个文件名 17、35 和三个存储其他磁盘页面地址的数据。根据算法我们发现：17<29<35，因此我们找到指针 p2。
    3.根据 p2 指针，我们定位到磁盘块 3，并将其中的信息导入内存。【磁盘 IO 操作 2 次】
    4.此时内存中有两个文件名 26，30 和三个存储其他磁盘页面地址的数据。根据算法我们发现：26<29<30，因此我们找到指针 p2。
    5.根据 p2 指针，我们定位到磁盘块 8，并将其中的信息导入内存。【磁盘 IO 操作 3 次】
    6.此时内存中有两个文件名 28，29。根据算法我们查找到文件名 29，并定位了该文件内存的磁盘地址。
    分析上面的过程，发现需要 3 次磁盘 IO 操作和 3 次内存查找操作。关于内存中的文件名查找，由于是一个有序表结构，可以利用折半查找提高效率。至于 IO 操作是影响整个 B 树查找效率的决定因素。

当然，如果我们使用平衡二叉树的磁盘存储结构来进行查找，磁盘 4 次，最多 5 次，而且文件越多，B 树比平衡二叉树所用的磁盘 IO 操作次数将越少，效率也越高。

## B+tree

![](assets/干货：mysql索引的数据结构/file-20251124153934416.png)

Paste_Image.png

- B+tree 的优点：

1. B+-tree 的磁盘读写代价更低
    ****B+-tree****HOLDER}**HOLDER}**的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对 B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说 IO 读写次数也就降低了。
    举个例子，假设磁盘中的一个盘块容纳 16bytes，而一个关键字 2bytes，一个关键字具体信息指针 2bytes。一棵 9 阶 B-tree(一个结点最多 8 个关键字) 的内部结点需要 2 个盘快。而****B+
    **B+-tree**磁盘中就是盘片旋转的时间)。
2. B+-tree 的查询效率更加稳定
    由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

# mysql 的两种存储引擎的索引存储机制

## MyISAM 索引实现

MyISAM 引擎使用 B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址。下图是 MyISAM 索引的原理图：

![](assets/干货：mysql索引的数据结构/file-20251124153945233.png)

Paste_Image.png

这里设表一共有三列，假设我们以 Col1 为主键，则上图是一个 MyISAM 表的主索引（Primary key）示意。可以看出 MyISAM 的索引文件仅仅保存数据记录的地址。在 MyISAM 中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复。如果我们在 Col2 上建立一个辅助索引，则此索引的结构如下图所示：

![](assets/干货：mysql索引的数据结构/file-20251124153957352.png)

Paste_Image.png

同样也是一颗 B+Tree，data 域保存数据记录的地址。因此，MyISAM 中索引检索的算法为首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址，读取相应数据记录。

MyISAM 的索引方式也叫做“非聚集”的。

## InnoDB 索引实现

虽然 InnoDB 也使用 B+Tree 作为索引结构，但具体实现方式却与 MyISAM 截然不同。

第一个重大区别是 InnoDB 的数据文件本身就是索引文件。从上文知道，MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在 InnoDB 中，表数据文件本身就是按 B+Tree 组织的一个索引结构，这棵树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。

![](assets/干货：mysql索引的数据结构/file-20251124154008866.png)

Paste_Image.png

上图是 InnoDB 主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为 InnoDB 的数据文件本身要按主键聚集，所以 InnoDB 要求表必须有主键（MyISAM 可以没有），如果没有显式指定，则 MySQL 系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，这个字段长度为 6 个字节，类型为长整形。

第二个与 MyISAM 索引的不同是 InnoDB 的辅助索引 data 域存储相应记录主键的值而不是地址。换句话说，InnoDB 的所有辅助索引都引用主键作为 data 域。例如，定义在 Col3 上的一个辅助索引：

![](assets/干货：mysql索引的数据结构/file-20251124154017215.png)

Paste_Image.png

这里以英文字符的 ASCII 码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。

了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了 InnoDB 的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在 InnoDB 中不是个好主意，因为 InnoDB 数据文件本身是一颗 B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持 B+Tree 的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。

ps 引用：

[http://blog.codinglabs.org/articles/theory-of-mysql-index.html](https://link.jianshu.com?t=http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

[http://blog.csdn.net/zhangliangzi/article/details/51367639](https://link.jianshu.com?t=http://blog.csdn.net/zhangliangzi/article/details/51367639)

[http://www.cnblogs.com/vincently/p/4526560.html](https://link.jianshu.com?t=http://www.cnblogs.com/vincently/p/4526560.html)

作者：小灰灰 besty

链接：https://www.jianshu.com/p/1775b4ff123a

来源：简书

著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
